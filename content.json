{"meta":{"title":"鲸落","subtitle":"","description":"个人笔记Hexo静态博客,记录学习各种编程笔记和过程,偶尔致敬生活.","author":"鲸落","url":"https://blog.ebig.vip","root":"/blog/"},"pages":[{"title":"","date":"2020-09-29T05:11:06.250Z","updated":"2020-09-29T05:11:06.250Z","comments":true,"path":"404.html","permalink":"https://blog.ebig.vip/404.html","excerpt":"","text":"页面未找到 很抱歉，您访问的页面不存在 请确认不是输入地址有误或该地址已被删除？"},{"title":"","date":"2020-10-13T07:23:07.633Z","updated":"2020-10-13T07:23:07.633Z","comments":true,"path":"MsgBoard/index.html","permalink":"https://blog.ebig.vip/MsgBoard/index.html","excerpt":"","text":"留 言 板"},{"title":"","date":"2020-10-12T12:20:24.442Z","updated":"2020-10-12T12:20:24.442Z","comments":false,"path":"about/index.html","permalink":"https://blog.ebig.vip/about/index.html","excerpt":"","text":"无论走到哪里都要记得,过去都是假的！ --马尔克斯 鲸落 A whale falls，all things are born"},{"title":"","date":"2020-09-14T04:48:37.202Z","updated":"2020-05-26T13:45:31.000Z","comments":true,"path":"archives/index.html","permalink":"https://blog.ebig.vip/archives/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-30T04:19:23.080Z","updated":"2020-09-30T04:19:23.080Z","comments":false,"path":"announce/index.html","permalink":"https://blog.ebig.vip/announce/index.html","excerpt":"","text":"公 告 2020-09-30 本站正在不断的努力优化中… 若有报错之处，还请留言告知。 感谢您的支持！ 之前 公告记录缺失！"},{"title":"","date":"2020-10-15T06:11:32.406Z","updated":"2020-10-15T06:11:32.406Z","comments":false,"path":"artitalk/index.html","permalink":"https://blog.ebig.vip/artitalk/index.html","excerpt":"","text":"new Artitalk({ appId: 'LsVyGClX0KpYsrymggJfKxcW-gzGzoHsz', appKey: 'De3cIKO1x4kotto8QUGgtSqq', serverURL: 'https://leancloud.ebig.vip', pageSize: 6, shuoPla: '想说点啥呢~', atEmoji: { //xaoxuu表情 weibo-doge: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/weibo/weibo-1.png\", weibo-doge-tuosai: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/weibo/weibo-2.png\", weibo-doge-shengqi: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/weibo/weibo-3.png\", weibo-doge-tushe: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/weibo/weibo-4.png\", aru-1: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-1.gif\", aru-2: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-2.gif\", aru-3: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-3.gif\", aru-4: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-4.gif\", aru-5: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-5.gif\", aru-6: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-6.gif\", aru-7: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-7.gif\", aru-8: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-8.gif\", aru-9: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-9.gif\", aru-10: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-10.gif\", aru-11: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-11.gif\", aru-12: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-12.gif\", aru-13: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-13.gif\", aru-14: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-14.gif\", aru-15: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-15.gif\", aru-16: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-16.gif\", aru-17: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-17.gif\", aru-18: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-18.gif\", aru-19: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-19.gif\", aru-20: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-20.gif\", aru-21: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-21.gif\", aru-22: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-22.gif\", aru-23: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-23.gif\", aru-24: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-24.gif\", aru-25: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-25.gif\", aru-26: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-26.gif\", aru-27: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-27.gif\", aru-28: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-28.gif\", aru-29: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-29.gif\", aru-30: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-30.gif\", aru-31: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-31.gif\", aru-32: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-32.gif\", aru-33: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-33.gif\", aru-34: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-34.gif\", aru-35: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-35.gif\", aru-36: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-36.gif\", aru-37: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-37.gif\", aru-38: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-38.gif\", aru-39: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-39.gif\", aru-40: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-40.gif\", aru-41: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-41.gif\", aru-42: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-42.gif\", aru-43: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-43.gif\", aru-44: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-44.gif\", aru-45: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-45.gif\", aru-46: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-46.gif\", aru-47: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-47.gif\", aru-48: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-48.gif\", aru-49: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-49.gif\", aru-50: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-50.gif\", aru-51: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-51.gif\", aru-52: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-52.gif\", aru-53: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-53.gif\", aru-54: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-54.gif\", aru-55: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-55.gif\", aru-56: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-56.gif\", aru-57: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-57.gif\", aru-58: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-58.gif\", aru-59: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-59.gif\", aru-60: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-60.gif\", aru-61: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-61.gif\", aru-62: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-62.gif\", aru-63: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-63.gif\", aru-64: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-64.gif\", aru-65: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-65.gif\", aru-66: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-66.gif\", aru-67: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-67.gif\", aru-68: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-68.gif\", aru-69: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-69.gif\", aru-70: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-70.gif\", aru-71: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-71.gif\", aru-72: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-72.gif\", aru-73: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-73.gif\", aru-74: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-74.gif\", aru-75: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-75.gif\", aru-76: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-76.gif\", aru-77: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-77.gif\", aru-78: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-78.gif\", aru-79: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-79.gif\", aru-80: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-80.gif\", aru-81: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-81.gif\", aru-82: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-82.gif\", aru-83: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-83.gif\", aru-84: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-84.gif\", aru-85: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-85.gif\", aru-86: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-86.gif\", aru-87: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-87.gif\", aru-88: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-88.gif\", aru-89: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-89.gif\", aru-90: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-90.gif\", aru-91: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-91.gif\", aru-92: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-92.gif\", aru-93: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-93.gif\", aru-94: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-94.gif\", aru-95: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-95.gif\", aru-96: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-96.gif\", aru-97: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-97.gif\", aru-98: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-98.gif\", aru-99: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-99.gif\", aru-100: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-100.gif\", aru-101: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-101.gif\", aru-102: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-102.gif\", aru-103: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-103.gif\", aru-104: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-104.gif\", aru-105: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-105.gif\", aru-106: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-106.gif\", aru-107: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-107.gif\", aru-108: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-108.gif\", aru-109: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-109.gif\", aru-110: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-110.gif\", aru-111: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-111.gif\", aru-112: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-112.gif\", aru-113: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-113.gif\", aru-114: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-114.gif\", aru-115: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-115.gif\", aru-116: \"https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/emoji/valine/aru/aru-116.gif\", }, })"},{"title":"分类","date":"2020-09-14T07:42:54.056Z","updated":"2020-09-14T07:42:54.056Z","comments":true,"path":"categories/index.html","permalink":"https://blog.ebig.vip/categories/index.html","excerpt":"","text":""},{"title":"软件工具下载","date":"2020-09-29T04:45:41.115Z","updated":"2020-09-29T04:45:41.115Z","comments":true,"path":"download/index.html","permalink":"https://blog.ebig.vip/download/index.html","excerpt":"","text":"谷歌访问助手2018百试不厌，还能用。 本站下载 Axure RP.v3654Axure RP是一款专业的快速原型设计工具。RP则是Rapid Prototyping（快速原型）的缩写。 官网下载链接 本文件集成了汉化以及授权码。 本站下载 ScreenToGif.v2.19.3电脑端录制制作gif图片! 官网下载链接 由于官网的下载速度过慢，故上传至此。 本站下载 Git.v2.25官网下载链接 由于官网的下载速度过慢，故上传至此。 本站下载 sublime Text.v3211官网下载链接 由于官网的下载速度过慢，故上传至此。 本站下载 xshell 和 xftp官网下载链接 下方链接是 家庭和学校用户的免费许可证版 本站下载"},{"title":"","date":"2020-10-13T06:16:43.778Z","updated":"2020-10-13T06:16:43.778Z","comments":true,"path":"friends/index.html","permalink":"https://blog.ebig.vip/friends/index.html","excerpt":"友 链","text":"友 链 来自Gitee 友链添加流程 申请网站需符合以下规则 符合法律法规！ 链接不得无法打开，或者内容质量低下 需要强制 https 协议 添加本站友链，直到不符合申请规则或单方面取消 添加本站到您的友链中123456名称：鲸落链接: https://ebig.vip头像: https://wbig.gitee.io/cdn/img/assets/avatar.jpg描述: 无论走到哪里都应该记住，过去都是假的！标签: Web前端博客截图:https://wbig.gitee.io/cdn/img/assets/screenshot.png优化图片加载速度为了提高图片加载速度，建议优化头像和截图：打开 压缩图 上传自己的头像，将图片尺寸调整到 96px 后下载。将压缩后的图片上传到 去不 图床 并使用此图片链接作为头像。重复上述步骤，把压缩网站截图并把尺寸调整到 540x360 以下。按照格式添加友链12345678&#123; &quot;title&quot;: &quot;&quot;, &quot;screenshot&quot;: &quot;&quot;, &quot;url&quot;: &quot;&quot;, &quot;avatar&quot;: &quot;&quot;, &quot;description&quot;: &quot;&quot;, &quot;keywords&quot;: &quot;&quot;&#125; 二选其一 动态提交 Gitee Issue静态评论区添加待审核通过 申请符合要求，互加好友成功。 感谢支持！还请多多指导。"},{"title":"","date":"2020-10-15T06:57:05.294Z","updated":"2020-10-15T06:57:05.294Z","comments":false,"path":"history/index.html","permalink":"https://blog.ebig.vip/history/index.html","excerpt":"","text":"建 站 史 2020-10-13 更改说说api地址 2020-10-13 增加动态添加友链 2020-10-12 修改站内图片路径 部分文章删除重做 2020-09-30 修改源文件样式适配超小屏 增加了公告历史页面 2020-09-29 升级主题到4.0.0正式版 迁移Github图床到Gitee 2020-09-15 域名访问加速失败 Gitee部署自定义域名失败！ 重新部署到 Github 首页图标换用 icon 增加评论QQ提醒功能 增加了留言板页面 增加了建站史页面 2020-09-14 部署 Gitee 使用Artitalk增加了说说页面，没事可以自己说两句 增加评论管理以及邮件提醒 全站使用Leancloud进行网站访问统计 2020-09-01 部署 Coding 失败！ 2020-08-20 升级4.0-beta版 2020-03-23 - 2020-08-20 文件记录缺失！ 2020-03-23 删除日历云生成 增加站内导航 增加分类雷达图 2020-03-17 修改volantis主题源文件 2020-03-16 更新同作者最新主题volantis 2020-02-15 舍弃七牛云，使用PicGo配置Github图床 2020-02-09 网站ICP备案成功 2020-02-01 文章专属归类文件夹 2020-01-23 使用Hexo部署成功！ 2020-01-16 建站探索"},{"title":"所有标签","date":"2020-09-14T07:42:41.820Z","updated":"2020-09-14T07:42:41.820Z","comments":true,"path":"tags/index.html","permalink":"https://blog.ebig.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"flex布局深究","slug":"web/flex","date":"2020-09-01T03:57:34.000Z","updated":"2020-10-13T04:31:16.768Z","comments":true,"path":"web/flex/","link":"","permalink":"https://blog.ebig.vip/web/flex/","excerpt":"flex布局深究，csdn访问","text":"前言对于 基础布局知识，阅读 flex布局教程 - 阮一峰 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大（瓜分剩余空间）。假设有三个子项 如果设置子项的 flex-grow: 1;， 则它们将按照比例 1 ：1 ：1 等分剩余空间。 如果设置第 一 个子项的flex-grow: 1;，第 二 个子项的flex-grow: 2;，第 三 个子项的flex-grow: 3;，则它们将按照比例 1 ：2 ：3 等分剩余空间。 flex-shrink我们都知道，flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 但是与flex-grow的放大比例有着完全不同的计算方式。 当设置了flex-shrink ，则 flex-grow 属性无效。 我们设置一个容器，包裹三个子项盒子 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 同时给上样式 123456789101112131415161718192021.wrapper &#123; width: 600px; height: 600px; border: 1px solid black; display: flex;&#125;.content &#123; width: 100px; height: 100px; flex-basis: 300px; /*优先于width*/ flex-shrink: 1; border: 1px solid green; box-sizing: border-box;&#125;.content:nth-of-type(3) &#123; flex-shrink: 3;&#125; 此时，三个子项的大小总共是 900，超过了 盒子600的大小，同时对三个子项设置了 flex-shrink，前两个盒子为1，第三个值为3 我们按照 flex-grow的扩展的计算方式进行测试，可以得到 而实际结果也是如此，但真的是这样么？当然不是！！！，主要原因在于 三个子项的宽度是相等的，然后误导将shrink的比例当做了缩减的比例。 我们再设置一个容器，包裹三个子项盒子 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 同时给上样式， 去掉子项边框，让其为整数值，方便计算！ 12345678910111213141516171819.wrapper &#123; width: 600px; height: 600px; border: 1px solid black; display: flex;&#125;.content &#123; width: 200px; height: 100px; flex-shrink: 1; &#125;.content:nth-of-type(3) &#123; width: 400px; flex-shrink: 3;&#125; 此时，三个子项的大小总共是 800，超过了 盒子600的大小 200，同时对三个子项设置了 flex-shrink，前两个盒子为1，第三个值为3。 按照刚刚测试的算法，1：1：3 对超出的 200 进行压缩可以得到第一个宽度为 200 - 40 = 160，第一个宽度为 200 - 40 = 160，第三个宽度为 400 -120 = 280 但实际测试结果为175 175 250，如此便可以验证压缩的计算方式，并不是扩展的计算方式 真实的计算方式则是所有子项的 真实（内容区）宽度 shrink值 相加，作为权值，为分母。 然后每个子项的真实宽度 shrink值/ 权值 再乘以多出来的部分，得到 压缩部分。再减去压缩部分得到实际宽度大小。 拿上述例子来计算。 这里就有一个值得注意的地方。在图片中 计算压缩大小的试子中，分子上是 真实宽度为啥呢？ 我们接着设置一个容器，包裹三个子项盒子 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 同时给上样式， 这次加上子项边框 123456789101112131415161718192021.wrapper &#123; width: 600px; height: 600px; border: 1px solid black; display: flex;&#125;.content &#123; width: 200px; height: 100px; flex-shrink: 1; border: 1px solid black; box-sizing: border-box;&#125;.content:nth-of-type(3) &#123; width: 400px; flex-shrink: 3;&#125; 可以得到实际结果如图 惊奇的发现，宽度竟然变成了小数，而且，加上padding的值也不等于计算出来的结果，虽然差不多。 但是如果将 border 去掉，就会发现和原来的一样，不同的地方，就是padding的值没了。 细心的可以知道：这个真实宽度就是指内容区的真实宽度。 我们再接着设置一个容器，包裹三个子项盒子去掉子项内容区的内容 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt; 同时给上样式， 加上颜色这次前两个盒子 不设置width，用padding代替宽度大小，去掉边框 123456789101112131415161718192021222324.wrapper &#123; width: 600px; height: 600px; border: 1px solid black; display: flex;&#125;.content &#123; height: 100px; padding: 0 100px; flex-shrink: 1; box-sizing: border-box; background-color: #f0f;&#125;.content:nth-of-type(2) &#123; background-color: #ff0;&#125;.content:nth-of-type(3) &#123; width: 400px; flex-shrink: 3; background-color: #0ff;&#125; 可以得到实际结果如图 惊奇的发现，它们宽度竟然一样。其实可以猜测，第一个和第二个都没有压缩，只有第三个压缩了。 相当于 第一个和第二个的 shrink值，都是 0 。 其权重 计算可以为 0 * 1 + 0 * 1 + xxx * 3。这样一来，只能在第三个上面压缩。 我们再再接着设置一个容器，包裹三个子项盒子 12345&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;&lt;/div&gt; 同时给上样式， 加上颜色这次设置80的padding 12345678910111213141516171819202122232425.wrapper &#123; width: 600px; height: 600px; border: 1px solid black; display: flex;&#125;.content &#123; width: 200px; height: 100px; padding: 0 80px; flex-shrink: 1; box-sizing: border-box; background-color: #f0f;&#125;.content:nth-of-type(2) &#123; background-color: #ff0;&#125;.content:nth-of-type(3) &#123; width: 400px; flex-shrink: 3; background-color: #0ff;&#125; 推测结果如图 真实效果如图 当设置了 flex-shrink属性同时遇到 box-sizing:border-box ， border或者padding，加权值在计算的时候，不是真实盒子宽度，而是内容区的宽度。 flex-basis当子项同时设置了 width和flex-basis，basis的优先级更高。 不做测试，直接结论！ 就是子项的width。权重高于width。 添加内容，当是英语单词的时候， 只写basis ，就代表width的最小值，即min-width 同时设置了basis和 width。 basis &lt; width basis是下限，width代表上限 basis &gt; width 则width无效了 当不换行内容撑开容器，设置了shrink，不参与压缩flex-shrink 可以设置中文 word-break:break-word强制换行","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"flex布局","slug":"flex布局","permalink":"https://blog.ebig.vip/tags/flex%E5%B8%83%E5%B1%80/"}]},{"title":"css中的基线","slug":"web/css-lineheight","date":"2020-07-21T15:21:00.000Z","updated":"2020-10-12T11:17:02.786Z","comments":true,"path":"web/css-lineheight/","link":"","permalink":"https://blog.ebig.vip/web/css-lineheight/","excerpt":"CSS基线","text":"Line-height行距、行间距行距： 相邻文本行间 上一个文本行基线 和 下一个文本行基线 之间的距离。 行间距： 相邻文本行间 上一个文本行下行线 和 下一个文本行上行线 之间的距离。 行距 = 行间距 + 字体大小 在CSS中，CSS属性line-height则是用于设置真实的行距。从W3C Rec中看出，line-height就是行距, 而line-height的字面意思即为“行高”，推导结果CSS中行高即是行距。 了解了行高，行距，行间距。那么接下来介绍line-height的重要属性–垂直居中。 我们知道，行距(leading) = 行间距(line-space) + 字体大小(font-size)。 行间距与字体大小都可以通过相应CSS属性设置，问题是行间距所占的空间是怎么分配的呢？ CSS采用的是将行间距对半开，然后分配到上下两端，这里引用了Half-leading的概念， Half-leading = 行距/2 由于行距可能为负值，可以知道行间距可能为负数，那么垂直居中还有效么？ 答案是肯定的，行间距为负数时，Half-leading 自然也是负数，只是上下两端从增加等量空间变为减少等量空间而已。如下例子： 123&lt;div style=&quot;position:relative;top:100px;font-size:90px;line-height:10px;background:yellow;&quot;&gt; &lt;span style=&quot;border:solid 1px red;line-height:10px;&quot;&gt;x&lt;/span&gt;&lt;/div&gt; line-height属性CSS line-height 属性 | 菜鸟教程 CSS line-height 属性 | W3school 值 描述 可能值 normal | &lt;number&gt; | &lt;lenght&gt; | &lt;percentage&gt; | &lt;inherit&gt; 默认值 normal 继承性 yes normal对于normal，其实就是一个值，但是由浏览器决定，实际值一般在1.0~1.2之间（闭区间） 不同浏览器下，normal 不同；同一浏览器下，font-size 不同，normal 也不同；同一浏览器下，font-size 相同，font-family 不同，normal 也会变化。 normal 的平均值确实是 1.0~1.2(闭区间)，但是具体到特定浏览器、font-family 和 font-size时，normal值可能会大于1.2。 length指定长度用于计算线盒高度，负值非法。 设置固定值，单位可以是 px 、pt 。 好处就是简单，设置是什么，line-height的实际高度就是什么。 坏处是子元素默认 继承 父容器的line-height，若子元素的font-size 大于 父容器的font-size，那么子元素的文本行会什么密集。 解决方案，一般是采用 相对 font-size 实际大小 来设置 line-height 值的方式，如默认 normal 方法。 percentage(%)计算值是百分比乘以元素计算字体大小，负值非法。 值的注意的是，参考系的确是font-size，但子元素继承的是父容器的实际 line-height 值，也就是说父容器设置为 font-size:20px;line-height:200%;，子元素继承的line-height值为 40px，而不是 200% ，因此又回到了 方式 的问题了。 number属性的使用值是 这个数字 乘以 元素的字体大小，负值非法，计算值与指定值相同。 和方式一样，以 font-size 为参考系，以相对值方式设置 line-height。 唯一不同的是，子元素继承的是父容器的值，参考系自动变为子元素的 font-size 123line-height: 1.2em;line-height: 1.2; 上门的两句其实是等价的，若想将参考系 改 为根元素的 font-size ， 需要CSS3的新增line-height:1.2rem;。 深入理解根据WCAG2.0(万维网内容可存取性指南)规定 “段落中的行距至少要1.5倍 ”，那么是否在body设置一下，就一劳永逸了呢？ CSS代码HTML代码12345678910111213body&#123; font-size: 16px; line-height: 1.5;&#125;h1 &#123; font-size:32px;&#125;p &#123; font-size:16px;&#125;#footer &#123; font-size:12px;&#125;123&lt;h1&gt;深入理解 line-height 和 vertical-align&lt;/h1&gt;&lt;p&gt;In my dual profession as an educator and health care provider, I have worked with numerous children infected with the virus that causes AIDS. The relationships that I have had with these special kids have been gifts in my life. They have taught me so many things, but I have especially learned that great courage can be found in the smallest of packages. Let me tell you about Tyler. &lt;/p&gt; &lt;div id=&quot;footer&quot;&gt;bed and whispered, “I might die soon. I’m not scared. When I die, please dress me in red. Mom promised she’s coming to heaven, too. I’ll be playing when she gets there, and I want to make sure she can find me.”&lt;/div&gt; 效果图 代码效果呈现如图，不难发现，对于 h1 标题来说，行距有点多，于是可以有如下配置： 123456body&#123; line-height:1.5;&#125;h1,h2,h3,h4,h5,h6&#123; line-height:1.2;&#125; vertical-align如何对齐属性CSS vertical-align 属性 | W3school CSS vertical-align 属性 | MDN web docs 它的属性规则还是比较多的，但是也不能都记，或者用的时候挨个查。归纳一下不难发现 对齐操作必定涉及操作元素和参考系元素，而vertical-align的值全是指的是参考系元素的位置，操作元素则以baseline或者linebox上中下作对齐； 默认对齐方式为baseline，数量值均是相对于baseline而言。 vertical-align 仅对 inline-level 和 table-cell 元素有效。 默认baseline1234&lt;div style=&quot;font-size:14px;&quot;&gt; &lt;span style=&quot;font-size:40px;&quot;&gt;line-height x vertical-align&lt;/span&gt; x for reference frame&lt;/div&gt; 这里的x for reference frame作为参考系，它的 baseline 就是 line-height x vertical-align 要对齐的。 在此 baseline 的基础上做出如下设置 在span中设置 vertical-align: 10px; 1234&lt;div style=&quot;font-size:14px;&quot;&gt; &lt;span style=&quot;font-size:40px;vertical-align:10px;&quot;&gt;line-height x vertical-align&lt;/span&gt; x for reference frame&lt;/div&gt; 在span中设置 vertical-align: -10px; 1234&lt;div style=&quot;font-size:14px;&quot;&gt; &lt;span style=&quot;font-size:40px;vertical-align:-10px;&quot;&gt;line-height x vertical-align&lt;/span&gt; x for reference frame&lt;/div&gt; 在div中设置line-height:1;， 同时在span中设置 vertical-align:50%; 1234&lt;div style=&quot;font-size:14px;line-height:1;&quot;&gt; &lt;span style=&quot;font-size:40px;vertical-align:50%;&quot;&gt;line-height x vertical-align&lt;/span&gt; x for reference frame&lt;/div&gt; 在div中设置line-height:1;， 同时在span中设置 vertical-align: -50%; 1234&lt;div style=&quot;font-size:14px;line-height:1;&quot;&gt; &lt;span style=&quot;font-size:40px;vertical-align: -50%;&quot;&gt;line-height x vertical-align&lt;/span&gt; x for reference frame&lt;/div&gt; top把元素 line box 上边框对齐父元素的 line box 上边框 text-top把元素的 line box 上边框对齐父元素的 ascent(即 content top edge) middle把元素 line box 中垂点与父元素基线 + x-height/2 的高度对齐 未完待续刚刚换了新的markdown标签，用起来比较费劲，码字效率比较低，还在熟悉中。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://blog.ebig.vip/tags/css/"}]},{"title":"js的console","slug":"web/js-console","date":"2020-07-20T12:23:00.000Z","updated":"2020-10-12T11:32:10.287Z","comments":true,"path":"web/js-console/","link":"","permalink":"https://blog.ebig.vip/web/js-console/","excerpt":"javascript的 console细致了解。","text":"console第一印象便是console.log，通过它在浏览器控制台进行调试输出。但除此之外还有许多方法。比如在访问百度首页时候的控制台，会有以下的内容。但是仔细一看，你会发现，它有颜色。怎么做到的呢？ 其实不难发现，输入console，可知它是一个对象，里面有着高达14个方法，而我们最常用只有一个log()，可怕。 Console - Web API 接口参考 | MDNhttps://developer.mozilla.org/zh-CN/docs/Web/API/Console JavaScript Console对象 | 菜鸟教程https://www.runoob.com/w3cnote/javascript-console-object.html 通过文档我们清晰的知道各个方法的作用，以及使用方法。 通过占位符，可以改变输出的内容和样式。其中 %c 被称为 CSS占位符。 详解console.log()首先，除了console.log(object)这种语法，还有 console.log(object, otherObject, string) 将所有东西都整齐的打印出来。另外，还有 console.log(msg, value)，通过占位符来输出，执行方式与 C 语言的输出类似。 对于 %c，输出样式。 一个 %c 是将此后所有内容都进行渲染 1console.log(&#x27;I am a %cbutton&#x27;, &#x27;color: white; background-color: orange; padding:2px 5px; border-radius: 2px&#x27;); 两个 %c 则是对其中间内容渲染。 1console.log(&#x27;I am a %cbutton%c not a div&#x27;, &#x27;color: white; background-color:orange; padding: 2px 5px; border-radius: 2px&#x27;,&#x27;color: &quot;auto&quot;&#x27;); 当然渲染的只是样式，没有实质性的功能（按钮，点击事件等） 如果想 %c 展示出来呢? 与 \\ 类似，写两个即可，比如将上述的语句展示出来。 1console.log(&#x27;I am a %cbutton%%c not a div&#x27;, &#x27;color: white; background-color:orange; padding: 2px 5px; border-radius: 2px&#x27;,&#x27;color: &quot;auto&quot;&#x27;); console.dir()通常看，它与 log() 的功能非常类似，但也有略微不同，主要在对文档结构的输出方面。 展开来看，log 只是输出了文档结构的内容，怎么写的怎么输出。清晰展示DOM节点，当我们选中时候，还可以跳转子DOM节点。 而 dir() 却是一种更对象化的输出方式观察元素节点，在监测元素节点方面，这种结果无疑是最好的。 console.warn()它可能是 log() 最直接明显的替换产生的方法，它的级别是warn级别而不是一个info级别，你可以将所有的 console.log() 过滤掉只留下 console.warn()。 在Vue的部分源码中也是使用 console.warn() 来操作的。 123456&#x2F;&#x2F;vue.jstip &#x3D; function (msg, vm) &#123; if (hasConsole &amp;&amp; (!config.silent)) &#123; console.warn(&quot;[Vue tip]: &quot; + msg + (vm ? generateComponentTrace(vm) : &#39;&#39;)); &#125;&#125;; console.table()这个，就是将对象数组展示为列表的数据方法，变得更加简洁可观。例如对一个对象数组使用此方法。 对于 log() 输出结果是一个小箭头的省略形式，展开来看，可以清晰的查看对象。 而 table() 的输出更加简洁，更直观展示。并且值得一提的是，可以通过第一行的右上角箭头可以进行排序。table() 最多只处理1000行的数据能力，不适用所有数据集合。 当然如果只想要某一列展示，可以通过第二个参数进行传递。 1console.table(transactions,[&quot;id&quot;,&quot;price&quot;]) log()输出table()输出 console.assert()它的第一个参数是 falsey 时，与 log() 函数无异。当第一个参数是真值的时候什么都不做。 牢记，它的作用是判断，而不是过滤。 它的使用场景与 循环时候要显示特殊的 数据相似。 123if(obj.num === 3)&#123; console.log(obj)&#125; 假设我们上面的值在时间戳里有一个 null 或者 0，这会破坏代码日期格式。 当和任何有效的事物对象一起使用时会跳过。但是有一个触发了我们的日志记录，因为时间戳在 0 和 null 时为假值。 有时候，想实现更加复杂的场景，举例，对于上述表格中看到了关于用户WAL2025的数据，并想展示来自它们的事务。 1console.assert(transactions.buyer === &#x27;WAL2025&#x27;, transactions); 看起来没毛病，但是并没有用，牢记，场景必须是否定态，它的作用是判断，而不是过滤。 1console.assert(transactions.buyer !== &#x27;WAL2025&#x27;, transactions); 结语剩下的方法，演示过于困难或者简单，还是看文档理解比较好。 Console - Web API 接口参考 | MDNhttps://developer.mozilla.org/zh-CN/docs/Web/API/Console JavaScript Console 对象 | 菜鸟教程https://www.runoob.com/w3cnote/javascript-console-object.html 其他方法的存在，让我们可以得到比 log() 的信息更多一些，并且不需要调试器的情况下，这些工具还是很有用的。 附图简洁直观的理解使用 console","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.ebig.vip/tags/JavaScript/"}]},{"title":"try-catch监听多线程","slug":"web/js-trycatch","date":"2020-06-21T15:21:00.000Z","updated":"2020-10-13T09:05:02.102Z","comments":true,"path":"web/js-trycatch/","link":"","permalink":"https://blog.ebig.vip/web/js-trycatch/","excerpt":"对于try-catch 这组函数，主要了解就是异常处理。 但是它对于多线程的处理机制是什么样呢？ 另外，js不是单线程么？多线程又是怎么回事？","text":"try-catch 函数基本使用当 JavaScript 引擎执行 JavaScript 代码时，可能会发生各种错误，可能是语法错误，通常是程序员造成的编码错误或错别字。可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。可能是由于来自服务器或用户的错误输出而导致的错误。当然，也可能是由于许多其他不可预知的因素。当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。这种情况被称为：JavaScript 抛出异常。对于可能出现的问题的代码我们需要预判，这就涉及到异常的测试与捕获。 123456try &#123; //在这里运行代码&#125;catch (err) &#123; //在这里处理错误&#125; try 语句允许我们定义在执行时进行错误测试的代码块。catch 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。JavaScript 语句 try 和 catch 是成对出现的。 有一个运行代码的函数 runCode 123function runCode(code) &#123; return eval(code);&#125; 当我们执行 runCode(‘1+1’) 可以得到 2，这里利用 eval 函数特性，可以执行字符串。eval 并不是我们这篇文章的主要内容。对于 code 是用户输入，当用户输入的内容是一段错误代码，我们的函数，就会报错，进而影响之后的逻辑执行。这是我们需要利用 try-catch 进行捕获。代码改写如下： 123456789function runCode(code) &#123; try &#123; // 接下来执行的 eval(code)可能会出错 return eval(code); &#125; catch (error) &#123; // 上面的部分报错，会对外输出错误信息，并不会终止程序 console.log(&#x27;代码存在错误&#x27;) &#125;&#125; 当我执行 runCode(‘aaaaa’), 会给我们提示信息： 代码存在错误，这样我们的错误就成功捕获，并不影响后面的逻辑执行。 使用 try-catch 的建议try catch 的使用，永远应该放在你的控制范围之内，而不应该防范未知的错误。也就是说你很清楚知道这里是有可能”出错“的，而且你很清楚知道什么前提下会出错，你就是要故意利用报错信息来区分错误，后续的程序会解决所有的出错，让程序继续执行。如果让用户先发现你根本没预料到的错误，而不是你先发现错误，你是失职的。 try-catch 与多线程JS 中的“多线程”浏览器中的 JavaScript 确实是以单线程的方式执行的，也就是说 JavaScript 执行使用一个主线程，但是 JavaScript 提供了异步操作，比如定时器(setTimeout、setInterval)事件、Ajax 请求、Promise, I/O 等。它们将会被放入浏览器的事件任务队列（event loop）中去，等到 JavaScript 运行时执行线程空闲时候，事件队列才会按照先进先出的原则被一一执行。但是对于以上的异步操作过程中，能进行的计时，发送请求，I/O 操作都是其他的线程在做的事情，所以说是“多线程”。 多线程不等于异步异步和多线程并不是一个同等关系,异步是最终目的,多线程只是我们实现异步的一种手段。异步是当一个调用请求发送给被调用者,而调用者不用等待其结果的返回而可以做其它的事情。实现异步可以采用多线程技术或则交给另外的进程来处理。 setTimeout 函数1234567try &#123; setTimeout(function () &#123; console.log(a.b) &#125;, 1000)&#125; catch (error) &#123; console.log(&#x27;有错误&#x27;)&#125; 控制台报错： a is not defined.，并没有被捕获。得出结论， try-catch 无法监听 setTime 函数中的错误。 Promise 函数1234567try &#123; let p = new Promise((resolve, reject) =&gt; &#123; a.b &#125;)&#125;catch (error) &#123; console.log(&#x27;有错误&#x27;)&#125; 控制台报错： a is not defined.，并没有被捕获。得出结论， try-catch 无法监听 Promise 函数中的错误。 Ajax 函数12345678910111213141516171819function ajax(url) &#123; var xhr = window.XMLHttpRequest ? new XMLHttpRequest() : ActiveXObject(&quot;microsoft.XMLHttp&quot;) xhr.open(&quot;get&quot;, url, true); xhr.send(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readystate == 4) &#123; if (xhr.status == 200) &#123; var data = xhr.responseTEXT; return data; &#125; &#125; &#125;&#125;try &#123; ajax(&#x27;someurl&#x27;)&#125; catch (error) &#123; console.log(&#x27;有错误&#x27;)&#125; Ajax 中的请求出错，并未被捕获。得出结论 try-catch 无法监听 Ajax 函数中的错误。 总结对于以上几种异步操作，我们看的出来 try-catch 并未帮我们监听的到里面的错误。原因是：javaScript 擎对异步方法进行 try/catch 操作只能捕获当次事件循环内的异常，对 call back 执行时抛出的异常将无能为力。但是对于异步操作，只要是代码逻辑没有问题，我们在适当的问题出口把问题暴露出去就可以了，比如 Promise 的 then，Ajax 的状态判断等等。","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.ebig.vip/tags/JavaScript/"}]},{"title":"HTTP相关知识","slug":"web/http","date":"2020-06-02T09:21:00.000Z","updated":"2020-10-12T11:31:47.623Z","comments":true,"path":"web/http/","link":"","permalink":"https://blog.ebig.vip/web/http/","excerpt":"HTTP相关知识","text":"http 与 https http是超文本传输协议，是目前世界上使用最多的协议。 它是用于从www服务器传输超文本到本地浏览器的传输协议。 https是安全的http通道，在http下加入了 SSL层。 https协议需要CA证书，费用高。 另外，使用不同的链接方式，端口也不一样，一般来说，http协议是80端口，https是443端口 https的工作原理 客户使用https url访问，要求web服务器建立ssl链接 web服务器收到后，会将网站的证书（证书中含公钥）返回给客户端 客户端与服务器端开始协商ssl链接的安全等级，也就是加密等级。 协商一致，建立会话秘钥，然后网站加密，web服务器解密，开始通信。 http请求的方式 http1.0 三种请求：get,post head http1.1 新增6种: options,put,patch,delete,trace,connect get:： 请求页面信息，返回实体主体。 head： 类似于get请求，只不过返回的响应中没有具体内容，用户获取报头。 post 向指定资源提交数据进行处理请求，数据包含在请求体中 get与post get用于获取数据，post用于提交数据 get参数在url后，post可以在http body中提交 get在url长度有限制，post数据可以很大 get提交可以在浏览器缓存，post不会被浏览器缓存 get不安全，因为参数暴露在url中 输入URL到页面加载显示完成发生了什么 DNS解析 TCP连接 发送HTTP请求 服务器处理并返回HTTP报文 浏览器解析渲染 连接结束 一个图片url访问后直接下载怎样实现请求的返回头里，用于浏览器解析的重要参数就是OSS的API文档的返回http头，决定用户下载行为的参数。 状态码 400： 请求无效：前端提交数据与后台实体不一致。 401： 需要用户验证。 403： 服务器得到请求，拒绝执行。 304： 未修改 如果客户端发送带条件的get请求且被允许，而文档的内容并没有改变 fetch发送2次请求的原因第一次发送Options请求，询问服务器是否支持修改的请求头，如果支持再发送。 cookie, sessionStorage和localStorage共同点： 都是保存在浏览器端，并且同源 不同点： 比较内容 cookie sessionStorage localStorage 数据 始终在同源的http请求中携带（即使不需要） 仅在本地保存 仅在本地保存 传递性 在浏览器与服务器之间来回传递 不会自动发送数据给服务器 不会自动发送数据给服务器 有效期 在设置的时间内一直有效，即使浏览器或者窗口关闭 仅在当前浏览器窗口关闭前有效 始终有效，窗口或浏览器关闭也一直保存 共享性 所有同源窗口共享 在所有同源窗口中都是共享 跨域问题 URL 说明 是否允许通信 &lt;http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 如果是协议与端口问题，前台是无能为力的 document.domain + iframe(主域相同) 动态创建script，script标签不受同源策略的限制 location.hash + iframe: 利用location.hash进行传值 window.name + iframe: name值在不同页面加载后依旧存在，最大2M postMessage (html5 中XMLHttpRequest level 2中的API) CORS（IE中是xdr）: 使用自定义的http头 让浏览器与服务器进行沟通 JSNP: 回调函数与数据 ，回调函数是当响应到来时要放在当前页面被调用的函数，数据是传入回调函数中的json数据，也就是回调函数的参数。支持get请求，不知道post。 web sockets： 一种浏览器API，目标是在一个单独的持久连接上提供全双工，双向通信，只有在支持web socket协议的服务器上才能正常工作。 doctype 作用告诉浏览器以何种方式渲染页面，严格模式与混杂模式。 cookie如何防范XSS攻击XSS: 跨站脚本攻击 httponly- 这个属性可以防止，它可以禁止JavaScript脚本访问cookie。 secure- 这个属性告诉浏览器仅在请求为https的时候发送cookie。 一句话概括RESTFUL就是用URL定位资源，用HTTP描述操作。 click在ios上有300ms延迟，原因及如何解决？ 粗暴型，禁用缩放。 使用fastclick，原理是监测到touchend事件后，立即模拟click事件，并且把浏览器30ms后真正的事件给阻断掉。 强缓存、协商缓存什么时候用哪个因为服务器上的资源不是一直固定不变的，大多数情况下它会更新，这个时候如果我们还访问本地缓存，那么对用户来说，那就相当于资源没有更新，用户看到的还是旧的资源；所以我们希望服务器上的资源更新了浏览器就请求新的资源，没有更新就使用本地的缓存，以最大程度的减少因网络请求而产生的资源浪费。 强缓存、协商缓存 强缓存是利用http头中的Expires和Cache-Control两个字段来控制的，用来表示资源的缓存时间。 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。协商缓存相关字段有Last-Modified/If-Modified-Since，Etag/If-None-Match 参考链接，'https://segmentfault.com/a/1190000008956069'https://wbig.gitee.io/cdn/img/assets/link.png 前端优化 降低请求量： 合并资源，减少http请求数，minify/gzip压缩，webP，lazyLoad 加快请求速度： 预解析DNS， 减少域名数，并行加载，CDN并发 缓存： http协议缓存请求，离线缓存，离线数据缓存 渲染：js/css优化，加载顺序，服务端渲染，pipeline csrf和xss的网络攻击及防范CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求 XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie 查看网站性能 插入探针或者脚本 搭建环境，模拟用户访问请求，采集数据 第三方工具","categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/categories/Web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"http协议","slug":"http协议","permalink":"https://blog.ebig.vip/tags/http%E5%8D%8F%E8%AE%AE/"}]},{"title":"JS 异步操作","slug":"wx-mini/wx-mini-cloud-js-promise","date":"2020-03-12T14:36:54.000Z","updated":"2020-10-12T11:31:25.639Z","comments":true,"path":"wx-mini/wx-mini-cloud-js-promise/","link":"","permalink":"https://blog.ebig.vip/wx-mini/wx-mini-cloud-js-promise/","excerpt":"解决微信小程序 JS 异步操作问题","text":"JS 异步操作js是单线程的，对于下面代码，执行顺序：当主线程输出 2 之后，空闲再执行输出 1 12345setTimeout(() =&gt; &#123; console.log(1)&#125;,1000)console.log(2) 假设如下代码，层层回调。不仅不能加解决问题，反而性能很差，影响用户体验。 1234567891011// callback hell 回调深渊setTimeout(() =&gt; &#123; console.log(1) setTimeout(() =&gt; &#123; console.log(2) setTimeout(() =&gt; &#123; console.log(3) &#125;) &#125;,2000)&#125;,1000) Es6 解决办法promise状态不可逆！！！！状态也不可相互转换！！！ 状态 说明 pending 既不成功也不失败 fulfilled 成功 rejected 失败 上面的回调语句用Promise 实现异步如下： 避免了层层回调的循环。将第一个事件的成功状态作为第二个事件的条件。 resolve( … ) … 为成功的返回值,可以为字符串 123456789101112new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(1) resolve() &#125;,1000)&#125;).then(res =&gt; &#123; setTimeout(() =&gt; &#123; console.log(2) &#125;,2000)&#125;).catch(err =&gt; &#123;&#125;) Promise.all() 方法12345678let p1 = new Promise(...)let p2 = new Promise(...)let p3 = new Promise(...)Promise.all([p1,p2,p3]).then(res =&gt; &#123; console.log(&#x27;全部完成&#x27;) console.log(res)&#125;).catch(..) 如果是说，p1中 reject() 。则promise.all将整体执行失败，但不影响里面p2 ,p3的进程继续执行 Promise.race() 方法1234Promise.race([p1,p2,p3]).then(res =&gt; &#123; console.log(&#x27;完成&#x27;) console.log(res)&#125;).catch(..) race 顾名思义，竞赛的意思。 即有一个任务完成就表示完成。主要用于判断请求是否超时。 ES7 解决办法1// async await 在云函数中使用，默认支持，小程序端不支持！ 保存一个runtime.js文件，在要用的js页引用。然后调用使用。 import regeneratorRuntime from 路径/runtime.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719/** * Copyright (c) 2014-present, Facebook, Inc. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */!(function(global) &#123; // &quot;use strict&quot;; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === &quot;function&quot; ? Symbol : &#123;&#125;; var iteratorSymbol = $Symbol.iterator || &quot;@@iterator&quot;; var asyncIteratorSymbol = $Symbol.asyncIterator || &quot;@@asyncIterator&quot;; var toStringTagSymbol = $Symbol.toStringTag || &quot;@@toStringTag&quot;; var inModule = typeof module === &quot;object&quot;; var runtime = global.regeneratorRuntime; if (runtime) &#123; if (inModule) &#123; // If regeneratorRuntime is defined globally and we&#x27;re in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; &#125; // Don&#x27;t bother evaluating the rest of this file if the runtime was // already defined globally. return; &#125; // Define the runtime globally (as expected by generated code) as either // module.exports (if we&#x27;re in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : &#123;&#125;; function wrap(innerFn, outerFn, self, tryLocsList) &#123; // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; &#125; runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there&#x27;s no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don&#x27;t have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) &#123; try &#123; return &#123; type: &quot;normal&quot;, arg: fn.call(obj, arg) &#125;; &#125; catch (err) &#123; return &#123; type: &quot;throw&quot;, arg: err &#125;; &#125; &#125; var GenStateSuspendedStart = &quot;suspendedStart&quot;; var GenStateSuspendedYield = &quot;suspendedYield&quot;; var GenStateExecuting = &quot;executing&quot;; var GenStateCompleted = &quot;completed&quot;; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = &#123;&#125;; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() &#123;&#125; function GeneratorFunction() &#123;&#125; function GeneratorFunctionPrototype() &#123;&#125; // This is a polyfill for %IteratorPrototype% for environments that // don&#x27;t natively support it. var IteratorPrototype = &#123;&#125;; IteratorPrototype[iteratorSymbol] = function () &#123; return this; &#125;; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([]))); if (NativeIteratorPrototype &amp;&amp; NativeIteratorPrototype !== Op &amp;&amp; hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) &#123; // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; &#125; var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = &quot;GeneratorFunction&quot;; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) &#123; [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123; prototype[method] = function(arg) &#123; return this._invoke(method, arg); &#125;; &#125;); &#125; runtime.isGeneratorFunction = function(genFun) &#123; var ctor = typeof genFun === &quot;function&quot; &amp;&amp; genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === &quot;GeneratorFunction&quot; : false; &#125;; runtime.mark = function(genFun) &#123; if (Object.setPrototypeOf) &#123; Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); &#125; else &#123; genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) &#123; genFun[toStringTagSymbol] = &quot;GeneratorFunction&quot;; &#125; &#125; genFun.prototype = Object.create(Gp); return genFun; &#125;; // Within the body of any async function, `await x` is transformed to // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test // `hasOwn.call(value, &quot;__await&quot;)` to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) &#123; return &#123; __await: arg &#125;; &#125;; function AsyncIterator(generator) &#123; function invoke(method, arg, resolve, reject) &#123; var record = tryCatch(generator[method], generator, arg); if (record.type === &quot;throw&quot;) &#123; reject(record.arg); &#125; else &#123; var result = record.arg; var value = result.value; if (value &amp;&amp; typeof value === &quot;object&quot; &amp;&amp; hasOwn.call(value, &quot;__await&quot;)) &#123; return Promise.resolve(value.__await).then(function(value) &#123; invoke(&quot;next&quot;, value, resolve, reject); &#125;, function(err) &#123; invoke(&quot;throw&quot;, err, resolve, reject); &#125;); &#125; return Promise.resolve(value).then(function(unwrapped) &#123; // When a yielded Promise is resolved, its final value becomes // the .value of the Promise&lt;&#123;value,done&#125;&gt; result for the // current iteration. result.value = unwrapped; resolve(result); &#125;, function(error) &#123; // If a rejected Promise was yielded, throw the rejection back // into the async generator function so it can be handled there. return invoke(&quot;throw&quot;, error, resolve, reject); &#125;); &#125; &#125; var previousPromise; function enqueue(method, arg) &#123; function callInvokeWithMethodAndArg() &#123; return new Promise(function(resolve, reject) &#123; invoke(method, arg, resolve, reject); &#125;); &#125; return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); &#125; // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; &#125; defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () &#123; return this; &#125;; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) &#123; var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) &#123; return result.done ? result.value : iter.next(); &#125;); &#125;; function makeInvokeMethod(innerFn, self, context) &#123; var state = GenStateSuspendedStart; return function invoke(method, arg) &#123; if (state === GenStateExecuting) &#123; throw new Error(&quot;Generator is already running&quot;); &#125; if (state === GenStateCompleted) &#123; if (method === &quot;throw&quot;) &#123; throw arg; &#125; // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); &#125; context.method = method; context.arg = arg; while (true) &#123; var delegate = context.delegate; if (delegate) &#123; var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) &#123; if (delegateResult === ContinueSentinel) continue; return delegateResult; &#125; &#125; if (context.method === &quot;next&quot;) &#123; // Setting context._sent for legacy support of Babel&#x27;s // function.sent implementation. context.sent = context._sent = context.arg; &#125; else if (context.method === &quot;throw&quot;) &#123; if (state === GenStateSuspendedStart) &#123; state = GenStateCompleted; throw context.arg; &#125; context.dispatchException(context.arg); &#125; else if (context.method === &quot;return&quot;) &#123; context.abrupt(&quot;return&quot;, context.arg); &#125; state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === &quot;normal&quot;) &#123; // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) &#123; continue; &#125; return &#123; value: record.arg, done: context.done &#125;; &#125; else if (record.type === &quot;throw&quot;) &#123; state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = &quot;throw&quot;; context.arg = record.arg; &#125; &#125; &#125;; &#125; // Call delegate.iterator[context.method](context.arg) and handle the // result, either by returning a &#123; value, done &#125; result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) &#123; var method = delegate.iterator[context.method]; if (method === undefined) &#123; // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield* loop. context.delegate = null; if (context.method === &quot;throw&quot;) &#123; if (delegate.iterator.return) &#123; // If the delegate iterator has a return method, give it a // chance to clean up. context.method = &quot;return&quot;; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === &quot;throw&quot;) &#123; // If maybeInvokeDelegate(context) changed context.method from // &quot;return&quot; to &quot;throw&quot;, let that override the TypeError below. return ContinueSentinel; &#125; &#125; context.method = &quot;throw&quot;; context.arg = new TypeError( &quot;The iterator does not provide a &#x27;throw&#x27; method&quot;); &#125; return ContinueSentinel; &#125; var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === &quot;throw&quot;) &#123; context.method = &quot;throw&quot;; context.arg = record.arg; context.delegate = null; return ContinueSentinel; &#125; var info = record.arg; if (! info) &#123; context.method = &quot;throw&quot;; context.arg = new TypeError(&quot;iterator result is not an object&quot;); context.delegate = null; return ContinueSentinel; &#125; if (info.done) &#123; // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was &quot;throw&quot; but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was &quot;next&quot;, forget context.arg since it has been // &quot;consumed&quot; by the delegate iterator. If context.method was // &quot;return&quot;, allow the original .return call to continue in the // outer generator. if (context.method !== &quot;return&quot;) &#123; context.method = &quot;next&quot;; context.arg = undefined; &#125; &#125; else &#123; // Re-yield the result returned by the delegate method. return info; &#125; // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; &#125; // Define Generator.prototype.&#123;next,throw,return&#125; in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = &quot;Generator&quot;; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers&#x27; implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn&#x27;t happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() &#123; return this; &#125;; Gp.toString = function() &#123; return &quot;[object Generator]&quot;; &#125;; function pushTryEntry(locs) &#123; var entry = &#123; tryLoc: locs[0] &#125;; if (1 in locs) &#123; entry.catchLoc = locs[1]; &#125; if (2 in locs) &#123; entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; &#125; this.tryEntries.push(entry); &#125; function resetTryEntry(entry) &#123; var record = entry.completion || &#123;&#125;; record.type = &quot;normal&quot;; delete record.arg; entry.completion = record; &#125; function Context(tryLocsList) &#123; // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [&#123; tryLoc: &quot;root&quot; &#125;]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); &#125; runtime.keys = function(object) &#123; var keys = []; for (var key in object) &#123; keys.push(key); &#125; keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() &#123; while (keys.length) &#123; var key = keys.pop(); if (key in object) &#123; next.value = key; next.done = false; return next; &#125; &#125; // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; &#125;; &#125;; function values(iterable) &#123; if (iterable) &#123; var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) &#123; return iteratorMethod.call(iterable); &#125; if (typeof iterable.next === &quot;function&quot;) &#123; return iterable; &#125; if (!isNaN(iterable.length)) &#123; var i = -1, next = function next() &#123; while (++i &lt; iterable.length) &#123; if (hasOwn.call(iterable, i)) &#123; next.value = iterable[i]; next.done = false; return next; &#125; &#125; next.value = undefined; next.done = true; return next; &#125;; return next.next = next; &#125; &#125; // Return an iterator with no values. return &#123; next: doneResult &#125;; &#125; runtime.values = values; function doneResult() &#123; return &#123; value: undefined, done: true &#125;; &#125; Context.prototype = &#123; constructor: Context, reset: function(skipTempReset) &#123; this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel&#x27;s // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = &quot;next&quot;; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) &#123; for (var name in this) &#123; // Not sure about the optimal order of these conditions: if (name.charAt(0) === &quot;t&quot; &amp;&amp; hasOwn.call(this, name) &amp;&amp; !isNaN(+name.slice(1))) &#123; this[name] = undefined; &#125; &#125; &#125; &#125;, stop: function() &#123; this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === &quot;throw&quot;) &#123; throw rootRecord.arg; &#125; return this.rval; &#125;, dispatchException: function(exception) &#123; if (this.done) &#123; throw exception; &#125; var context = this; function handle(loc, caught) &#123; record.type = &quot;throw&quot;; record.arg = exception; context.next = loc; if (caught) &#123; // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = &quot;next&quot;; context.arg = undefined; &#125; return !! caught; &#125; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === &quot;root&quot;) &#123; // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle(&quot;end&quot;); &#125; if (entry.tryLoc &lt;= this.prev) &#123; var hasCatch = hasOwn.call(entry, &quot;catchLoc&quot;); var hasFinally = hasOwn.call(entry, &quot;finallyLoc&quot;); if (hasCatch &amp;&amp; hasFinally) &#123; if (this.prev &lt; entry.catchLoc) &#123; return handle(entry.catchLoc, true); &#125; else if (this.prev &lt; entry.finallyLoc) &#123; return handle(entry.finallyLoc); &#125; &#125; else if (hasCatch) &#123; if (this.prev &lt; entry.catchLoc) &#123; return handle(entry.catchLoc, true); &#125; &#125; else if (hasFinally) &#123; if (this.prev &lt; entry.finallyLoc) &#123; return handle(entry.finallyLoc); &#125; &#125; else &#123; throw new Error(&quot;try statement without catch or finally&quot;); &#125; &#125; &#125; &#125;, abrupt: function(type, arg) &#123; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; if (entry.tryLoc &lt;= this.prev &amp;&amp; hasOwn.call(entry, &quot;finallyLoc&quot;) &amp;&amp; this.prev &lt; entry.finallyLoc) &#123; var finallyEntry = entry; break; &#125; &#125; if (finallyEntry &amp;&amp; (type === &quot;break&quot; || type === &quot;continue&quot;) &amp;&amp; finallyEntry.tryLoc &lt;= arg &amp;&amp; arg &lt;= finallyEntry.finallyLoc) &#123; // Ignore the finally entry if control is not jumping to a // location outside the try/catch block. finallyEntry = null; &#125; var record = finallyEntry ? finallyEntry.completion : &#123;&#125;; record.type = type; record.arg = arg; if (finallyEntry) &#123; this.method = &quot;next&quot;; this.next = finallyEntry.finallyLoc; return ContinueSentinel; &#125; return this.complete(record); &#125;, complete: function(record, afterLoc) &#123; if (record.type === &quot;throw&quot;) &#123; throw record.arg; &#125; if (record.type === &quot;break&quot; || record.type === &quot;continue&quot;) &#123; this.next = record.arg; &#125; else if (record.type === &quot;return&quot;) &#123; this.rval = this.arg = record.arg; this.method = &quot;return&quot;; this.next = &quot;end&quot;; &#125; else if (record.type === &quot;normal&quot; &amp;&amp; afterLoc) &#123; this.next = afterLoc; &#125; return ContinueSentinel; &#125;, finish: function(finallyLoc) &#123; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) &#123; this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel; &#125; &#125; &#125;, &quot;catch&quot;: function(tryLoc) &#123; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) &#123; var record = entry.completion; if (record.type === &quot;throw&quot;) &#123; var thrown = record.arg; resetTryEntry(entry); &#125; return thrown; &#125; &#125; // The context.catch method must only be called with a location // argument that corresponds to a known catch block. throw new Error(&quot;illegal catch attempt&quot;); &#125;, delegateYield: function(iterable, resultName, nextLoc) &#123; this.delegate = &#123; iterator: values(iterable), resultName: resultName, nextLoc: nextLoc &#125;; if (this.method === &quot;next&quot;) &#123; // Deliberately forget the last sent value so that we don&#x27;t // accidentally pass it on to the delegate. this.arg = undefined; &#125; return ContinueSentinel; &#125; &#125;; &#125;)( // In sloppy mode, unbound `this` refers to the global object, fallback to // Function constructor if we&#x27;re in global strict mode. That is sadly a form // of indirect eval which violates Content Security Policy. (function() &#123; return this &#125;)() || Function(&quot;return this&quot;)() ); awiat 必须在async中使用。否则无效 request-promise在小程序中使用 request-promise 可以快捷处理js异步问题，但是，云数据库只支持插入单条数据 突破云函数限制 云函数 限制最多读取100条数据 小程序端 限制最多读取20条数据 如何突破这种限制 测试代码 1234567891011121314151617181920212223242526272829303132333435363738//假设数据有210条数据//计算总数也是一个异步的过程。let count = await playlistCollection.count()//此时count是一个对象, 获取当前总的数据let total = countResult.total//一次最多读100条MAX_LIMIT = 100//那分三次读出 向上取整let batchTimes = Math.ceil((total / MAX_LIMIT))// 每次取数据的时候都是异步操作，// 每次的异步任务完成后，再拼接let tasks = []for(let i = 0; i &lt; batchTimes; i++)&#123; //每次取的数据开始地址不一样 let promiseId = playlistCollection.skip(i * MAX_LIMIT).limit(MAX_LIMIT).get() tasks.push(promiseId)&#125;let list = &#123; data: []&#125;if(tasks.length &gt; 0)&#123;// acc 之前的值// cur 当前循环遍历的值 list = (await Promise.all(tasks)).reduce((acc, cur) =&gt; &#123; return &#123; data: acc.data.concat(cur.data) &#125; &#125;)&#125; 定时触发器 触发云函数 在云函数右键创建 config.json 填写内容 上传触发器 上传前确认，json文件没有注释 上传触发器代码触发器代码理解 触发器代码理解 123456789&#123; &quot;triggers&quot;: [ &#123; &quot;name&quot;: &quot;myTrigger&quot;, &quot;type&quot;: &quot;timer&quot;, &quot;config&quot;: &quot;0 0 10,14,16,23 * * * *&quot; &#125; ]&#125; 触发器代码 1234567891011121314151617181920212223&#123; // triggers 字段是触发器数组，目前仅支持一个触发器，即数组只能填写一个，不可添加多个 // JSON 文件不能添加注释，此处是为了截图 好理解 &quot;triggers&quot;: [ &#123; // name: 触发器的名字，规则见下方说明 &quot;name&quot;: &quot;myTrigger&quot;, // type: 触发器类型，目前仅支持 timer (即 定时触发器) &quot;type&quot;: &quot;timer&quot;, // config: 触发器配置，在定时触发器下，config 格式为 cron 表达式，规则见下方说明//0 0 2 1 * * * 表示在每月的1日的凌晨2点触发//0 15 10 * * MON-FRI * 表示在周一到周五每天上午10: 15触发//0 0 10,14,16 * * * * 表示在每天上午10点，下午2点，4点触发//0 */30 9-17 * * * * 表示在每天上午9点到下午5点内每半小时触发//0 0 12 * * WED * 表示在每个星期三中午12点触发 &quot;config&quot;: &quot;0 0 10,14,16,23 * * * *&quot; &#125; ]&#125;","categories":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.ebig.vip/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.ebig.vip/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"js异步操作","slug":"js异步操作","permalink":"https://blog.ebig.vip/tags/js%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"}]},{"title":"Hello My Website","slug":"Hello-My-Website","date":"2020-01-23T08:05:51.000Z","updated":"2020-10-12T10:13:38.781Z","comments":true,"path":"Hello-My-Website/","link":"","permalink":"https://blog.ebig.vip/Hello-My-Website/","excerpt":"欢迎来到我的网站! 这是我的第一个线上网站，稍有雏形！","text":"关于网站这是我的第一个线上网站，历经6天，才像个样子！ 此网站部署在 Github ，我曾经尝试过本地服务器，但内网穿透比较难，知识有限，便放弃了！ 使用Hexo和volantis主题配置。 然后把自己想说的，不想说的，该说的，不该说的，我应该都会在这里写下来。 网站暂未提交到百度检索收录！等真正稳定了，文章有内容干货的时候再提交！ 如果您对网站有任何问题以及见解，欢迎斧正！ 鲸落鲸落是我的QQ昵称，也伴随了我大学生活以及现在。一开始只是觉得该换用了很久很久不知道多久的昵称，后面渐渐了解它的含义。 行吧，就它了！懒得换，就是字数少了点！ 有时回想起某一段时间，还真是五味杂陈。 鲸落 A whale falls，all things are born","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ebig.vip/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ebig.vip/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://blog.ebig.vip/tags/Volantis/"}]}],"categories":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/categories/Web%E5%89%8D%E7%AB%AF/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.ebig.vip/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ebig.vip/categories/Hexo/"}],"tags":[{"name":"Web前端","slug":"Web前端","permalink":"https://blog.ebig.vip/tags/Web%E5%89%8D%E7%AB%AF/"},{"name":"flex布局","slug":"flex布局","permalink":"https://blog.ebig.vip/tags/flex%E5%B8%83%E5%B1%80/"},{"name":"css","slug":"css","permalink":"https://blog.ebig.vip/tags/css/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.ebig.vip/tags/JavaScript/"},{"name":"http协议","slug":"http协议","permalink":"https://blog.ebig.vip/tags/http%E5%8D%8F%E8%AE%AE/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://blog.ebig.vip/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"js异步操作","slug":"js异步操作","permalink":"https://blog.ebig.vip/tags/js%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.ebig.vip/tags/Hexo/"},{"name":"Volantis","slug":"Volantis","permalink":"https://blog.ebig.vip/tags/Volantis/"}]}